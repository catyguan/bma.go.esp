【帧结构】
头:4个字节
	[1:帧类型][3:体大小]
	例子：帧类型为1，长度为1000
	[1][0][3][232]
体:变长数据，由头的体大小数据决定

【消息结构】
[帧][帧][帧][帧][结束帧]

结束帧 = 帧类型为0
	[0][0][0][0]
  
除了结束帧必须在消息的最后，其他帧无顺序要求（业务有特别要求除外）

【基础数据编码说明】
Bool : 布尔值，1字节
	0 false
	非0 true
Int = Int32
Int8 or Uint8 or Byte : 一个字节的定长数据
Int16,Int32,Int64 : 变长的有符号整型数据（需讨论）
	编码：
	uv := uint64(v) << 1
	if v < 0 {
		uv = ^uv // 取反 ~uv
	}
	return UintXEncoder(uv)
	解码：
	ux, n := UintXDecoder(buf)
	x := int64(ux >> 1)
	if ux&1 != 0 {
		x = ^x // 取反 ~x
	}
	return x, n
Uint = Uint32
Uint16,Uint32,Uint64 : 变长的无符号整型数据（需讨论）
	编码：
	i := 0
	for v >= 0x80 {
		buf[i] = byte(v) | 0x80
		v >>= 7
		i++
	}
	buf[i] = byte(v)
	return i + 1
	解码：
	var x uint64
	var s uint
	for i, b := range buf {
		if b < 0x80 {
			if i > 9 || i == 9 && b > 1 {
				return 0, -(i + 1) // overflow
			}
			return x | uint64(b)<<s, i + 1
		}
		x |= uint64(b&0x7f) << s
		s += 7
	}
	return 0, 0
FixInt16, FixInt32, FixInt64, FixUint16, FixUint32, FixUint64 : 定长的数据
	编码顺序 BigEndian
	16为2个字节
	32为4个字节
	64为8个字节
Float32 : 定长的4字节浮点数据
	根据IEEE 754格式转换为uint32然后FixUint32编码
Float64 : 定长的8字节浮点数据
	根据IEEE 754格式转换为uint64然后FixUint64编码
Bytes : 二进制数据，不定长
String : UTF8编码字符串，不定长
LenBytes : 具有长度的二进制数据
	[字节长度:Int][Bytes]
LenString : 具有长度的字符串
	[字节长度:Int][String]
Var : 类型长度都不定的数据
	[数据类型:1个字节][数据体]
	数据类型编号
	0 - Null
	1 - Bool
	2 - Int
	3 - Int8
	4 - Int16
	5 - Int32
	6 - Int64
	7 - Uint
	8 - Uint8
	9 - Uint16
	10 - Uint32
	11 - Uint64
	13 - Float32
	14 - Float64
	17 - LenBytes
	21 - Map<String, Var>
		[Map数量:Int][[Key:LenString][Value:Var]] ...
	23 - List<Var>
		[List数量:Int][Value:Var]...
	24 - LenString
 
【帧类型说明】
MT_END : 0x00
	结束帧，无帧数据，恒为 [0][0][0][0]
	
MT_RESERVERD ： 0x01 - 0x0F
	保留范围
	
MT_SESSION_INFO : 0x10
	会话数据，当响应该消息的时候，需要复制该帧数据到响应消息里
	可有多个
	数据体：[名称:LenString][值:Var]
	
MT_MESSAGE_ID : 0x11
	消息的编号，同一通信通道，该编号需要唯一
	数据体：[FixUint64]

MT_SOURCE_MESSAGE_ID : 0x12
	源消息的编号，可以通过该帧获取响应消息对应的源消息
	数据体：[FixUint64]	

// 取消，采用MT_FLAG代替
MT_MESSAGE_KIND : 0x13
	消息的类型
		MK_UNKNOW   = 0 无
		MK_REQUEST  = 1 请求
		MK_RESPONSE = 2 响应
		MK_INFO     = 3 消息
		MK_INFO_RESPONSE = xxx
		MK_EVENT    = 4 事件
	数据体：[Uint8]
	
MT_HEADER : 0x14
	通用消息头，Key：Value模型
	可有多个
	数据体：[名称:LenString][值:Var]
	
MT_DATA : 0x15
	通用消息数据，Key：Value模型
	可有多个
	数据体：[名称:LenString][值:Var]
	
MT_PAYLOAD : 0x16
	消息有效数据，数据格式由业务解析
	可有多个
	数据体：[Bytes]
	
MT_ADDRESS : 0x17
	消息目标地址
	可有多个
	数据体：[地址类型:Int][值:LenString]	
	地址类型
		ADDRESS_GROUP   = 50 服务组
		ADDRESS_HOST    = 40 主机(节点)
		ADDRESS_SERVICE = 30 服务
		ADDRESS_OP      = 20 操作
		ADDRESS_OBJECT  = 10 操作关联对象
	
MT_SOURCE_ADDRESS : 0x18
	消息源地址
	和MT_ADDRESS一样
	
// 取消，采用MT_FLAG代替
MT_TRACE : 0x19
	TRACE标志，表示该消息需要中间件反馈事件，用于调试用途
	该标志作用需要考虑是否通用
	数据体：无

// 取消，采用MT_FLAG代替
MT_TRACE_RESP : 0x1A
	TRACE响应标志，表示该消息是TRACE的对应响应消息
	数据体：无
	
MT_SEQ_NO : 0x1B
	消息序号，当一个业务逻辑需要多个消息才能完成的时候，通过该帧标志消息的序列编号
	数据体：[当前序号:Int][最大序号:Int]
		编号从1开始
		最大序号可以为0，表示未知
		当前序号 = 最大序号 表示已全部发送（该业务逻辑的最后一个消息）
	
MT_XDATA : 0x1C
	定制消息数据，Id:Value
	可有多个
	数据体：[Id:Int][值:业务解析]
	
MT_ERROR : 0x1D
	错误信息，如果是响应且有该信息，则表示是请求出现错误了
	数据体: [string]
	
MT_FLAG : 0x1E
	标志位
	可有多个
	数据体: [int32]
	Flag类型
		FLAG_TRACE   	= 1 需要中间件反馈事件，用于调试用途
		FLAG_TRACE_INFO = 2 是TRACE的对应响应消息
		FLAG_RESP		= 3 响应
		FLAG_REQUEST 	= 4 请求
		FLAG_INFO		= 5 消息
		FLAG_EVENT 		= 6 事件
		FLAG_APP_DEFINE = 128 应用定义
	
MT_VERSION : 0x1F
	协议版本号,4位字节表示
	[主版本][次版本][分支编号][变体编号]
	数据体: [byte][byte][byte][byte]

MT_APP_DEFINE ： 0x80 - 0xFF
	应用可使用的定制范围	

